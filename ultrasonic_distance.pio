.program ultrasonic_distance

; Clock divider is 1.0 so each instruction is 8ns (125MHz)

; The system will put this value in the Tx FIFO which we grab with the pull instruction.
; We want the trigger pulse to be high for 10us.
; 1250 instructions * 8ns/instr = 10us.
; We define it to be 1248 because setting the loop counter to 1248 means the loop will run
; 1249 times. Then add 1 for the set instruction (before the loop) and that gives us 1250.
.define PUBLIC TRIGGER_PULSE_CYCLES 1248

; echo pin is the first of the input pins
.define ECHO_INPUT_PIN 0

.wrap_target
	pull block 					; Wait for system to put the value in the FIFO, osr now has 1248.
	mov y, osr					; Put 1248 in the y register, y is used for the loop counter.

	set pins, 1					; trigger pin is now high for 1 instruction
still_triggering:
	jmp y-- still_triggering	; Trigger pin will still be high for 1249 times through the loop.
								; It jumps to beginning of loop if y!=0. It decrements y after it checks for 0;
								; This means that on the final pass through the loop, y was decremented from 0
								; to 0xFFFFFFFF. We will use this value of y in the next loop. We count down from
								; 0xFFFFFFFF while measuring the echo pulse width.

	set pins, 0					; trigger pin is now low
	
	wait 1 pin ECHO_INPUT_PIN	; Wait for start of echo pulse (wait for rising edge).

echo_still_high:				; The loop here normally executes 2 instructions, thus each iteration of the loop is 16ns.
	jmp y-- decrement_done		; Decrement the counter in y, then normally we jump over the next instruction, unless y has decremented all the way to 0...
	jmp timed_out				; ...unlikely we would ever get here. If we do, y was 0 then decremented to 0xFFFFFFFF. The system can check for this value.
decrement_done:
	jmp pin echo_still_high		; The 2nd main instruction in the loop. If echo is still high then loop again, otherwise continue to below.

echo_low:
timed_out:
	mov isr, y					; Whether the echo pulse is done or we timed out, move the counter in y to the input shift register.
	push						; Push the counter in the input shift register to the Rx FIFO so the system can grab it and do the calculation.
								; Ex: If counter is 0xFFFFFFFE then the loop ran 1 time. In that case 0xFFFFFFFF - 0xFFFFFFFE = 1 loop.
								; Num loops * 16ns/loop (2 instructions in loop) + 8ns (wait instruction before loop) = total time for echo pulse.

.wrap
